#include <TFT_eSPI.h>

TFT_eSPI tft = TFT_eSPI(); // 建立 TFT_eSPI 物件

const int SCREEN_WIDTH = 240; // 螢幕寬度
const int SCREEN_HEIGHT = 240; // 螢幕高度
const int NUM_SCREENS = 3; // 畫面數量

// 創建 sprite，將大小設為螢幕大小，用於顯示畫面
TFT_eSprite screen = TFT_eSprite(&tft);
screen.createSprite(SCREEN_WIDTH, SCREEN_HEIGHT);

int current_screen = 0; // 當前顯示的畫面
int start_x = 0; // 拖曳開始的 x 座標
int x_offset = 0; // 畫面的水平偏移量

void setup() {
  tft.init(); // 初始化 TFT_eSPI 物件
  tft.setRotation(1); // 設定螢幕方向

  drawScreen1(); // 畫面 1
  drawScreen2(); // 畫面 2
  drawScreen3(); // 畫面 3
}

void loop() {
  getTouch(); // 取得觸控輸入
}

void getTouch() {
  static int last_x = -1; // 上一次的 x 座標
  static bool is_dragging = false; // 是否正在拖曳

  int x, y;
  bool is_touched = tft.getTouch(&x, &y);
  
  if (is_touched && !is_dragging) {
    // 手指按下時，記錄起始座標
    start_x = x;
    is_dragging = true;
  } else if (!is_touched && is_dragging) {
    // 手指放開時，計算移動距離，更新顯示區域
    int dx = x - start_x;
    if (dx > SCREEN_WIDTH / 4) {
      current_screen = (current_screen + 1) % NUM_SCREENS;
      x_offset = 0;
    } else if (dx < -SCREEN_WIDTH / 4) {
      current_screen = (current_screen - 1 + NUM_SCREENS) % NUM_SCREENS;
      x_offset = 0;
    }
    is_dragging = false;
    last_x = -1;
  } else if (is_dragging && x != last_x) {
    // 手指移動時，計算移動距離，更新顯示區域
    int dx = x - start_x;
    x_offset = dx;
    if (current_screen == 0 && x_offset > 0) {
      x_offset = 0;
    } else if (current_screen == NUM_SCREENS - 1 && x_offset < 0) {
      x_offset = 0;
    }
    drawScreen(current_screen, x_offset);
    last_x = x;
    
    
    void loop() {
  // 等待手指觸碰螢幕
  while (!getTouch()) {}

  // 記錄手指的初始位置和時間
  int start_x = x;
  unsigned long start_time = millis();

  // 等待手指離開螢幕
  while (getTouch()) {}

  // 計算手指移動的距離和時間
  int delta_x = x - start_x;
  unsigned long delta_t = millis() - start_time;

  // 計算手指滑動的速度
  float speed = abs(delta_x) / (float) delta_t * 1000;

  // 如果手指滑動的距離大於閾值，或者手指滑動的速度大於閾值，或者手指滑動的時間大於閾值，則進行畫面切換
  if (abs(delta_x) > 50 || speed > 100 || delta_t > 200) {
    // 計算下一個要顯示的畫面索引
    int next_screen_index = current_screen_index;
    if (delta_x < 0) {
      next_screen_index++;
      if (next_screen_index >= NUM_SCREENS) {
        next_screen_index = 0;
      }
    } else {
      next_screen_index--;
      if (next_screen_index < 0) {
        next_screen_index = NUM_SCREENS - 1;
      }
    }

    // 切換畫面
    current_screen_index = next_screen_index;
    drawScreen();
  }
}

  }
}

void drawScreen(int screen_index, int x_offset) {
  // 將 sprite 移動到正確的位置
  screen.setPos(x_offset, 0);

  // 清空 sprite 的畫面
  screen.fillSprite(TFT_BLACK);
  switch (screen_index) {
case 0:
drawScreen1();
break;
case 1:
drawScreen2();
break;
case 2:
drawScreen3();
break;
default:
break;
}

// 將 sprite 的畫面顯示在螢幕上
screen.pushSprite(0, 0);
}

void drawScreen1() {
// 畫面 1 的內容
}

void drawScreen2() {
// 畫面 2 的內容
}

void drawScreen3() {
// 畫面 3 的內容
}
/*

這個版本的程式碼在 `drawScreen()` 函數中判斷當前顯示的畫面，然後呼叫相應的繪製函數，例如 `drawScreen1()`、`drawScreen2()` 等等。

當手指移動時， `getTouch()` 函數會計算手指移動的距離，並更新 `x_offset` 變數，然後呼叫 `drawScreen()` 函數以顯示畫面。這裡使用 `setPos()` 函數將 sprite 移動到正確的位置，然後再繪製畫面並顯示在螢幕上。

使用 sprite 可以使程式碼更簡潔，並且可以輕鬆實現手指移動時畫面跟著移動的效果。

v1.1
你是對的，如果僅根據手指移動距離來決定是否進行畫面切換，可能會漏掉一些快速滑動的情況。因此，我們可以考慮加入一些額外的條件來進行判斷，例如：

計算手指滑動的速度，如果速度超過一個閾值，例如 100 像素/秒，則認為是快速滑動，可以進行畫面切換。
計算手指滑動的時間，如果時間超過一個閾值，例如 200 毫秒，則認為是長時間滑動，可以進行畫面切換。
這些額外的條件可以提高判斷的準確度，使得畫面切換更加靈敏和順暢。以下是一個示範程式碼，用於判斷是否要切換畫面（包括上述兩個條件）：

在這個示範程式碼中，我們根據手指移動距離、手指滑動速度和手指滑動時間三個條件來判斷是否進行畫面切換。如果
其中，閾值可以根據需要進行調整，以適應不同的應用場景。比如，如果希望手指滑動距離更長才進行畫面切換，可以增加閾值；如果希望手指滑動速度更快才進行畫面切換，可以減小閾值。

需要注意的是，這種判斷方式可能會導致一些問題，比如：

手指滑動距離較短但速度較快的情況，可能會被誤判為快速滑動。
手指滑動距離較長但速度較慢的情況，可能會被誤判為長時間滑動。
因此，你需要根據具體情況來調整閾值，以達到最佳的判斷效果。另外，還可以根據實際情況進行進一步優化，比如增加手指滑動方向的判斷等，以提高畫面切換的精確度和順暢度。
*/
// by chat gpt and linche
